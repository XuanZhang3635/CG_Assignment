#version 450#extension GL_ARB_separate_shader_objects : enable#define PI 3.14159265359layout(location = 0) in vec3 fragPos;layout(location = 1) in vec3 fragNorm;layout(location = 2) in vec4 fragTan;layout(location = 3) in vec2 fragUV;layout(location = 0) out vec4 outColor;layout(binding = 1) uniform sampler2D tex;layout(binding = 3) uniform sampler2D normMap;layout(binding = 4) uniform sampler2D matMap;layout(binding = 2) uniform GlobalUniformBufferObject {    vec3 lightDir;    vec4 lightColor;    vec3 eyePos;} gubo;float DistributionGGX(vec3 N, vec3 H, float roughness){    float a      = roughness*roughness;    float a2     = a*a;    float NdotH  = max(dot(N, H), 0.0);    float NdotH2 = NdotH*NdotH;        float num   = a2;    float denom = (NdotH2 * (a2 - 1.0) + 1.0);    denom = PI * denom * denom;        return num / denom;}float GeometrySchlickGGX(float NdotV, float roughness){    float r = (roughness + 1.0);    float k = (r*r) / 8.0;    float num   = NdotV;    float denom = NdotV * (1.0 - k) + k;        return num / denom;}float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness){    float NdotV = max(dot(N, V), 0.0);    float NdotL = max(dot(N, L), 0.0);    float ggx2  = GeometrySchlickGGX(NdotV, roughness);    float ggx1  = GeometrySchlickGGX(NdotL, roughness);        return ggx1 * ggx2;}vec3 fresnelSchlick(float cosTheta, vec3 F0){    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);}vec3 BRDF(vec3 V, vec3 N, vec3 L, vec3 Md, float F0, float metallic, float roughness) {    //vec3 V  - direction of the viewer    //vec3 N  - normal vector to the surface    //vec3 L  - light vector (from the light model)    //vec3 Md - main color of the surface    //float F0 - Base color for the Fresnel term    //float metallic - parameter that mixes the diffuse with the specular term.    //                 in particular, parmeter K seen in the slides is: float K = 1.0f - metallic;    //float roughness - Material roughness (parmeter rho in the slides).    //specular color Ms is not passed, and implicitely considered white: vec3 Ms = vec3(1.0f);        vec3 f_diff = Md * clamp(dot(L,N),0.0,1.0);    vec3 h_lx = normalize(L+V);    float D = DistributionGGX(N, h_lx, roughness);    float G = GeometrySmith(N, V, L, roughness);    vec3 F00 = mix(vec3(F0),Md,metallic);    vec3 F = fresnelSchlick(clamp(dot(h_lx, V), 0.0, 1.0), F00);    vec3 f_specu = D * G * F / ( 4 * clamp(dot(N, V), 0.0 ,1.0) );        return (1.0f-metallic)*f_diff + metallic*f_specu;}void main() {    vec3 Norm = normalize(fragNorm);    vec3 Tan = normalize(fragTan.xyz - Norm * dot(fragTan.xyz, Norm));    vec3 Bitan = cross(Norm, Tan) * fragTan.w;    mat3 tbn = mat3(Tan, Bitan, Norm);    vec4 nMap = texture(normMap, fragUV);    vec3 N = normalize(tbn * (nMap.rgb * 2.0 - 1.0));    vec3 albedo = texture(tex, fragUV).rgb;    vec4 MRAO = texture(matMap, fragUV);    float roughness = MRAO.g;    float ao = MRAO.b;    float metallic = MRAO.r;        vec3 L = gubo.lightDir;    vec3 lightColor = gubo.lightColor.rgb;    vec3 V = normalize(gubo.eyePos - fragPos);    vec3 DiffSpec = BRDF(V, N, L, albedo, 0.3f, metallic, roughness);    vec3 Ambient = albedo * 0.05f * ao;        outColor = vec4(clamp(0.95 * DiffSpec * lightColor.rgb + Ambient,0.0,1.0), 1.0f);}